# consol_apis

**Usecase:** consolidate apis

**Created:** 1755628491

---

Hey Blow, We have these two methods on our timeline/mod.rs

```rust
 /// Get movement intent at a specific timestamp using partition_point for optimal boundary finding
/// Returns the most recent movement event before or at the timestamp
///
/// Uses partition_point which directly finds where the predicate changes from true to false,
/// clarifying the logic than binary_search_by with its Ok/Err handling
#[must_use]
pub fn get_movement_intent_at(&self, timestamp: TimeStamp) -> Option<GridPos> {
    // partition_point finds the first index where timestamp > t, so we work backwards from there
    // This is more idiomatic than binary_search_by for finding boundaries in sorted sequences
    let mut i = self.events.partition_point(|e| e.timestamp <= timestamp);
    while i > 0 {
        i -= 1; // Move to the last index with ts â‰¤ timestamp
        if let EventType::Movement(pos) = self.events[i].event_type {
            return Some(pos);
        }
    }
    None
}

/// Get abilities within a time window
/// Returns an iterator over events that contain abilities within the specified range
#[must_use]
pub fn abilities_in_window(
    &self,
    start: TimeStamp,
    end: TimeStamp,
) -> impl Iterator<Item=&TimelineEvent> + '_ {
    self.events_in_range(start, end)
        .filter(|e| matches!(e.event_type, EventType::Ability(_, _)))
}
```

They are very similar and not useful as the test case you wrote in the tutorials
`_docs/recording_system/tutorials/01_hello_world.md`

```rust
    #[test]
fn test_next_event_after_edge_cases() {
    let mut draft = DraftTimeline::new();

    // Add events at specific timestamps
    draft.add_event(TimelineEvent {
        timestamp: TimeStamp::new(10.0),
        event_type: EventType::Movement(GridPos::new(0, 0)),
    });
    draft.add_event(TimelineEvent {
        timestamp: TimeStamp::new(20.0),
        event_type: EventType::Ability(AbilityType::AutoShot, None),
    });
    draft.add_event(TimelineEvent {
        timestamp: TimeStamp::new(30.0),
        event_type: EventType::Movement(GridPos::new(1, 0)),
    });

    let published = PublishTimeline::from_draft(draft);

    // Test: Find next event after a timestamp with no exact match
    let next = published.next_event_after(TimeStamp::new(15.0));
    assert!(next.is_some());
    assert_eq!(next.unwrap().timestamp, TimeStamp::new(20.0));

    // Test: Find next event when timestamp matches exactly
    let next = published.next_event_after(TimeStamp::new(20.0));
    assert!(next.is_some());
    assert_eq!(next.unwrap().timestamp, TimeStamp::new(30.0));

    // Test: No next event when at or past last event
    let next = published.next_event_after(TimeStamp::new(30.0));
    assert!(next.is_none());

    let next = published.next_event_after(TimeStamp::new(35.0));
    assert!(next.is_none());

    // Test: Find first event when timestamp is before all events
    let next = published.next_event_after(TimeStamp::new(5.0));
    assert!(next.is_some());
    assert_eq!(next.unwrap().timestamp, TimeStamp::new(10.0));
}
```

This API is VERY close to `get_movement_intent_at` however, the `get_movement_intent_at` only does one type of event.
I don't think I need an api that just focuses on a single event type and rather it should be more like
`next_event_after`.

- Please read the `_docs/recording_system/recording.md` to confirm if my thinking is correct.
- Please read the `src/**/*.rs` to confirm if my thinking is correct.
- If you agree with the direction, Please refactor ALL the tutorials.
- If you agree with the direction, Please ensure my tests pass.
- If you do NOT agree, give me the 5Ws to justify.

